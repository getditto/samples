package live.ditto.dittotesting

import android.content.Context
import android.util.Log
import androidx.test.platform.app.InstrumentationRegistry
import live.ditto.DittoDependencies
import live.ditto.android.DefaultAndroidDittoDependencies
import live.ditto.android.TestAndroidDittoDependencies
import org.junit.AssumptionViolatedException
import org.junit.Before
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runners.model.Statement
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader

/**
 * Android-specific test base class
 */
open class DittoTestBase {
    @JvmField
    val context: Context = InstrumentationRegistry.getInstrumentation().targetContext

    @JvmField
    var dependencies: DittoDependencies = TestAndroidDittoDependencies(context)

    @Before
    open fun initialize() {
        dependencies = TestAndroidDittoDependencies(context)
        clearUpDittoDirectories(context)
    }

    companion object {
        @JvmField
        val LOCK: Any = Any()
    }

    /**
     * Returns a directory suitable for storing files generated by the test. Android tests use the
     * app Context to find the files directory on the device or emulator.
     */
    fun getWorkDir(): File = context.filesDir

    /**
     * Creates a set of Android dependencies combining defaults with a custom directory.
     */
    fun dependenciesWithCustomDirectory(customDir: File): DittoDependencies {
        val dependencies = DefaultAndroidDittoDependencies(context)
        return CustomDirectoryAndroidDittoDependencies(dependencies, customDir)
    }
}

const val LOGCAT_HEADER = "\n==================== Logcat Output ===================="
const val STACKTRACE_HEADER = "\n===================== Stacktrace ====================="
const val ORIGINAL_CLASS_HEADER = "\nOriginal class: "

class CaptureLogcatOnTestFailureRule : TestRule {
    override fun apply(statement: Statement, description: Description): Statement {
        return object : Statement() {
            override fun evaluate() {
                try {
                    // Runs the statement as given by the TestRunner
                    statement.evaluate()
                } catch (originalThrowable: Throwable) {
                    if (originalThrowable is AssumptionViolatedException) {
                        // Test runners know to skip this type of failure
                        throw originalThrowable
                    }

                    val logcatMessage = getRelevantLogsAfterTestStart(description.methodName).toString()

                    // We put out own custom message into the throwable, making sure to keep the
                    // original message in place.
                    val originalMsg = originalThrowable.localizedMessage
                    val originalClass = originalThrowable.javaClass.name
                    val thrownMessage = "$originalMsg $ORIGINAL_CLASS_HEADER $originalClass $LOGCAT_HEADER $logcatMessage $STACKTRACE_HEADER"

                    // Create a throwable with the same stacktrace as the actual failure. By using
                    // the original stacktrace this logcat addition is a transparent process to
                    // anyone reading the test failure report.
                    val modifiedThrowable = Throwable(thrownMessage)

                    // Since our Throwable doesn't know about the original error, we have to give it
                    // that information via our custom message and pass it a stacktrace explicitly.
                    modifiedThrowable.stackTrace = originalThrowable.stackTrace
                    throw modifiedThrowable
                }
            }
        }
    }
}

fun getRelevantLogsAfterTestStart(testName: String): StringBuilder {
    val builder = StringBuilder()

    // The process id is used to filter the messages. This TestRunner and the test itself run in the
    // same process.
    val currentProcessId = android.os.Process.myPid().toString()

    // A snippet of text that uniquely determines where the relevant logs start in the logcat.
    val testStartMessage = "TestRunner: started: $testName"

    // Flag that, when true, starts the recording of every line from the buffer to the string
    // builder.
    var isRecording = false

    // Our logcat command
    //
    // -d states for the command to completely dump to our buffer, then return
    // -v threadtime sets the output log format
    val command = listOf("logcat", "-d", "-v", "threadtiime").toTypedArray()

    var bufferedReader: BufferedReader? = null
    try {
        val process = Runtime.getRuntime().exec(command)
        bufferedReader = BufferedReader(InputStreamReader(process.inputStream))

        bufferedReader.forEachLine { line ->
            if (line.contains(currentProcessId)) {
                if (line.contains(testStartMessage)) {
                    isRecording = true
                }
                if (isRecording) {
                    builder.append(line)
                    builder.append("\n")
                }
            }
        }
    } catch (ex: IOException) {
        Log.e("DittoTestBase", "Failed to run logcat command: ${ex.localizedMessage}")
    } finally {
        if (bufferedReader != null) {
            try {
                bufferedReader.close()
            } catch (ex: IOException) {
                Log.e("DittoTestBase", "Failed to close buffered reader: ${ex.localizedMessage}")
            }
        }
    }

    // Once the logcat is cleared, the next run of this logcat reader will have a much shorter
    // buffer to deal with, resulting in a faster read time.
    clearLogcat()
    return builder
}

// TODO: Unsure if this is what this is supposed to do...
fun clearLogcat() {
    val command = listOf("logcat", "-b", "all", "-c").toTypedArray()
    val process = Runtime.getRuntime().exec(command)
    process.waitFor()
}